{"ast":null,"code":"import { factory } from '../../utils/factory.js';\nimport { isFunctionAssignmentNode, isSymbolNode } from '../../utils/is.js';\nimport { createMap } from '../../function/matrix/map.js';\nimport { compileInlineExpression } from './utils/compileInlineExpression.js';\nvar name = 'map';\nvar dependencies = ['typed'];\nexport var createMapTransform = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Attach a transform function to math.map\n   * Adds a property transform containing the transform function.\n   *\n   * This transform creates a one-based index instead of a zero-based index\n   */\n  var map = createMap({\n    typed\n  });\n  function mapTransform(args, math, scope) {\n    if (args.length === 0) {\n      return map();\n    }\n    if (args.length === 1) {\n      return map(args[0]);\n    }\n    var N = args.length - 1;\n    var X, callback;\n    callback = args[N];\n    X = args.slice(0, N);\n    X = X.map(arg => _compileAndEvaluate(arg, scope));\n    if (callback) {\n      if (isSymbolNode(callback) || isFunctionAssignmentNode(callback)) {\n        // a function pointer, like filter([3, -2, 5], myTestFunction)\n        callback = _compileAndEvaluate(callback, scope);\n      } else {\n        // an expression like filter([3, -2, 5], x > 0)\n        callback = compileInlineExpression(callback, math, scope);\n      }\n    }\n    return map(...X, _transformCallback(callback, N));\n    function _compileAndEvaluate(arg, scope) {\n      return arg.compile().evaluate(scope);\n    }\n  }\n  mapTransform.rawArgs = true;\n  return mapTransform;\n\n  /**\n   * Transforms the given callback function based on its type and number of arrays.\n   *\n   * @param {Function} callback - The callback function to transform.\n   * @param {number} numberOfArrays - The number of arrays to pass to the callback function.\n   * @returns {*} - The transformed callback function.\n   */\n  function _transformCallback(callback, numberOfArrays) {\n    if (typed.isTypedFunction(callback)) {\n      return _transformTypedCallbackFunction(callback, numberOfArrays);\n    } else {\n      return _transformCallbackFunction(callback, callback.length, numberOfArrays);\n    }\n  }\n\n  /**\n   * Transforms the given typed callback function based on the number of arrays.\n   *\n   * @param {Function} typedFunction - The typed callback function to transform.\n   * @param {number} numberOfArrays - The number of arrays to pass to the callback function.\n   * @returns {*} - The transformed typed callback function.\n   */\n  function _transformTypedCallbackFunction(typedFunction, numberOfArrays) {\n    var signatures = Object.fromEntries(Object.entries(typedFunction.signatures).map(_ref2 => {\n      var [signature, callbackFunction] = _ref2;\n      var numberOfCallbackInputs = signature.split(',').length;\n      if (typed.isTypedFunction(callbackFunction)) {\n        return [signature, _transformTypedCallbackFunction(callbackFunction, numberOfArrays)];\n      } else {\n        return [signature, _transformCallbackFunction(callbackFunction, numberOfCallbackInputs, numberOfArrays)];\n      }\n    }));\n    if (typeof typedFunction.name === 'string') {\n      return typed(typedFunction.name, signatures);\n    } else {\n      return typed(signatures);\n    }\n  }\n}, {\n  isTransformFunction: true\n});\n\n/**\n * Transforms the callback function based on the number of callback inputs and arrays.\n * There are three cases:\n * 1. The callback function has N arguments.\n * 2. The callback function has N+1 arguments.\n * 3. The callback function has 2N+1 arguments.\n *\n * @param {Function} callbackFunction - The callback function to transform.\n * @param {number} numberOfCallbackInputs - The number of callback inputs.\n * @param {number} numberOfArrays - The number of arrays.\n * @returns {Function} The transformed callback function.\n */\nfunction _transformCallbackFunction(callbackFunction, numberOfCallbackInputs, numberOfArrays) {\n  if (numberOfCallbackInputs === numberOfArrays) {\n    return callbackFunction;\n  } else if (numberOfCallbackInputs === numberOfArrays + 1) {\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      var vals = args.slice(0, numberOfArrays);\n      var idx = _transformDims(args[numberOfArrays]);\n      return callbackFunction(...vals, idx);\n    };\n  } else if (numberOfCallbackInputs > numberOfArrays + 1) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      var vals = args.slice(0, numberOfArrays);\n      var idx = _transformDims(args[numberOfArrays]);\n      var rest = args.slice(numberOfArrays + 1);\n      return callbackFunction(...vals, idx, ...rest);\n    };\n  } else {\n    return callbackFunction;\n  }\n}\n\n/**\n * Transforms the dimensions by adding 1 to each dimension.\n *\n * @param {Array} dims - The dimensions to transform.\n * @returns {Array} The transformed dimensions.\n */\nfunction _transformDims(dims) {\n  return dims.map(dim => dim.isBigNumber ? dim.plus(1) : dim + 1);\n}","map":{"version":3,"names":["factory","isFunctionAssignmentNode","isSymbolNode","createMap","compileInlineExpression","name","dependencies","createMapTransform","_ref","typed","map","mapTransform","args","math","scope","length","N","X","callback","slice","arg","_compileAndEvaluate","_transformCallback","compile","evaluate","rawArgs","numberOfArrays","isTypedFunction","_transformTypedCallbackFunction","_transformCallbackFunction","typedFunction","signatures","Object","fromEntries","entries","_ref2","signature","callbackFunction","numberOfCallbackInputs","split","isTransformFunction","_len","arguments","Array","_key","vals","idx","_transformDims","_len2","_key2","rest","dims","dim","isBigNumber","plus"],"sources":["/home/eduvazquez/Documents/github/web/projects/practicas-react/node_modules/mathjs/lib/esm/expression/transform/map.transform.js"],"sourcesContent":["import { factory } from '../../utils/factory.js';\nimport { isFunctionAssignmentNode, isSymbolNode } from '../../utils/is.js';\nimport { createMap } from '../../function/matrix/map.js';\nimport { compileInlineExpression } from './utils/compileInlineExpression.js';\nvar name = 'map';\nvar dependencies = ['typed'];\nexport var createMapTransform = /* #__PURE__ */factory(name, dependencies, _ref => {\n  var {\n    typed\n  } = _ref;\n  /**\n   * Attach a transform function to math.map\n   * Adds a property transform containing the transform function.\n   *\n   * This transform creates a one-based index instead of a zero-based index\n   */\n  var map = createMap({\n    typed\n  });\n  function mapTransform(args, math, scope) {\n    if (args.length === 0) {\n      return map();\n    }\n    if (args.length === 1) {\n      return map(args[0]);\n    }\n    var N = args.length - 1;\n    var X, callback;\n    callback = args[N];\n    X = args.slice(0, N);\n    X = X.map(arg => _compileAndEvaluate(arg, scope));\n    if (callback) {\n      if (isSymbolNode(callback) || isFunctionAssignmentNode(callback)) {\n        // a function pointer, like filter([3, -2, 5], myTestFunction)\n        callback = _compileAndEvaluate(callback, scope);\n      } else {\n        // an expression like filter([3, -2, 5], x > 0)\n        callback = compileInlineExpression(callback, math, scope);\n      }\n    }\n    return map(...X, _transformCallback(callback, N));\n    function _compileAndEvaluate(arg, scope) {\n      return arg.compile().evaluate(scope);\n    }\n  }\n  mapTransform.rawArgs = true;\n  return mapTransform;\n\n  /**\n   * Transforms the given callback function based on its type and number of arrays.\n   *\n   * @param {Function} callback - The callback function to transform.\n   * @param {number} numberOfArrays - The number of arrays to pass to the callback function.\n   * @returns {*} - The transformed callback function.\n   */\n  function _transformCallback(callback, numberOfArrays) {\n    if (typed.isTypedFunction(callback)) {\n      return _transformTypedCallbackFunction(callback, numberOfArrays);\n    } else {\n      return _transformCallbackFunction(callback, callback.length, numberOfArrays);\n    }\n  }\n\n  /**\n   * Transforms the given typed callback function based on the number of arrays.\n   *\n   * @param {Function} typedFunction - The typed callback function to transform.\n   * @param {number} numberOfArrays - The number of arrays to pass to the callback function.\n   * @returns {*} - The transformed typed callback function.\n   */\n  function _transformTypedCallbackFunction(typedFunction, numberOfArrays) {\n    var signatures = Object.fromEntries(Object.entries(typedFunction.signatures).map(_ref2 => {\n      var [signature, callbackFunction] = _ref2;\n      var numberOfCallbackInputs = signature.split(',').length;\n      if (typed.isTypedFunction(callbackFunction)) {\n        return [signature, _transformTypedCallbackFunction(callbackFunction, numberOfArrays)];\n      } else {\n        return [signature, _transformCallbackFunction(callbackFunction, numberOfCallbackInputs, numberOfArrays)];\n      }\n    }));\n    if (typeof typedFunction.name === 'string') {\n      return typed(typedFunction.name, signatures);\n    } else {\n      return typed(signatures);\n    }\n  }\n}, {\n  isTransformFunction: true\n});\n\n/**\n * Transforms the callback function based on the number of callback inputs and arrays.\n * There are three cases:\n * 1. The callback function has N arguments.\n * 2. The callback function has N+1 arguments.\n * 3. The callback function has 2N+1 arguments.\n *\n * @param {Function} callbackFunction - The callback function to transform.\n * @param {number} numberOfCallbackInputs - The number of callback inputs.\n * @param {number} numberOfArrays - The number of arrays.\n * @returns {Function} The transformed callback function.\n */\nfunction _transformCallbackFunction(callbackFunction, numberOfCallbackInputs, numberOfArrays) {\n  if (numberOfCallbackInputs === numberOfArrays) {\n    return callbackFunction;\n  } else if (numberOfCallbackInputs === numberOfArrays + 1) {\n    return function () {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n      var vals = args.slice(0, numberOfArrays);\n      var idx = _transformDims(args[numberOfArrays]);\n      return callbackFunction(...vals, idx);\n    };\n  } else if (numberOfCallbackInputs > numberOfArrays + 1) {\n    return function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n      var vals = args.slice(0, numberOfArrays);\n      var idx = _transformDims(args[numberOfArrays]);\n      var rest = args.slice(numberOfArrays + 1);\n      return callbackFunction(...vals, idx, ...rest);\n    };\n  } else {\n    return callbackFunction;\n  }\n}\n\n/**\n * Transforms the dimensions by adding 1 to each dimension.\n *\n * @param {Array} dims - The dimensions to transform.\n * @returns {Array} The transformed dimensions.\n */\nfunction _transformDims(dims) {\n  return dims.map(dim => dim.isBigNumber ? dim.plus(1) : dim + 1);\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}